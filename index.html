<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Jerome’s Assault</title>
    <style>
        canvas {
            border: 1px solid black;
            display: block;
            margin: 0 auto;
            background: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAYAAACNMs+9AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAJ0lEQVQYlWNgYGD4z8DA8P+fgeE/DQyM/yRg+P8PA8P/DQz/DwMAfH8mB2kF2RgAAAAASUVORK5CYII=') repeat; /* Tiled metal texture */
        }
        body {
            text-align: center;
            background: #111;
            color: white;
            font-family: Arial, sans-serif;
        }
        #upgrades {
            margin: 10px;
        }
        button {
            padding: 5px 10px;
            margin: 5px;
            background: #333;
            color: white;
            border: 1px solid #555;
            cursor: pointer;
        }
        button:hover {
            background: #555;
        }
    </style>
</head>
<body>
    <h1>Jerome’s Assault</h1>
    <p>Score: <span id="score">0</span> | Round: <span id="round">1</span> | HP: <span id="health">100</span></p>
    <div id="upgrades">
        <button onclick="buyUpgrade('shotgun')">Shotgun (100)</button>
        <button onclick="buyUpgrade('rifle')">Rifle (500)</button>
        <button onclick="buyUpgrade('speed')">Speed Boost (300)</button>
        <button onclick="buyUpgrade('health')">Health Pack (200)</button>
    </div>
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score');
        const roundDisplay = document.getElementById('round');
        const healthDisplay = document.getElementById('health');
        const upgradesDiv = document.getElementById('upgrades');

        // Player object
        const player = {
            x: canvas.width / 2,
            y: canvas.height / 2,
            radius: 20,
            speed: 5,
            hp: 100,
            bullets: [],
            weapon: { name: 'pistol', damage: 10, rate: 500, spread: 0, recoil: 2, shots: 1 },
            lastShot: 0,
            angle: 0,
            recoilOffset: { x: 0, y: 0 }
        };

        // Game state
        let enemies = [];
        let particles = [];
        let muzzleFlashes = [];
        let score = 0;
        let round = 1;
        let roundTime = 0;
        let roundTransitionTime = 0;
        let inTransition = false;
        let enemySpeed = 2;
        let spawnRate = 5000;

        // Input handling
        const keys = {};
        window.addEventListener('keydown', (e) => keys[e.key] = true);
        window.addEventListener('keyup', (e) => keys[e.key] = false);
        canvas.addEventListener('click', shoot);
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            player.angle = Math.atan2(mouseY - player.y, mouseX - player.x);
        });

        // Bullet class
        class Bullet {
            constructor(x, y, dx, dy, spread) {
                this.x = x;
                this.y = y;
                this.dx = dx + (Math.random() - 0.5) * spread;
                this.dy = dy + (Math.random() - 0.5) * spread;
                this.radius = player.weapon.name === 'shotgun' ? 3 : 5;
                this.speed = player.weapon.name === 'rifle' ? 15 : 10;
                this.damage = player.weapon.damage;
            }
            update() {
                this.x += this.dx * this.speed;
                this.y += this.dy * this.speed;
            }
            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = player.weapon.name === 'rifle' ? '#FFA500' : 'yellow';
                ctx.fill();
            }
        }

        // Blood particle class
        class Particle {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = Math.random() * 3 + 1;
                this.dx = (Math.random() - 0.5) * 4;
                this.dy = (Math.random() - 0.5) * 4;
                this.life = 30;
                this.color = Math.random() < 0.5 ? '#8B0000' : '#FF0000';
            }
            update() {
                this.x += this.dx;
                this.y += this.dy;
                this.life--;
                this.radius *= 0.95;
            }
            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
            }
        }

        // Muzzle flash class
        class MuzzleFlash {
            constructor(x, y, angle) {
                this.x = x;
                this.y = y;
                this.angle = angle;
                this.life = 5;
            }
            update() {
                this.life--;
            }
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(15, 5);
                ctx.lineTo(25, 0);
                ctx.lineTo(15, -5);
                ctx.fillStyle = 'rgba(255, 165, 0, ' + (this.life / 5) + ')';
                ctx.fill();
                ctx.restore();
            }
        }

        // Enemy class (Middle Eastern-inspired)
        class Enemy {
            constructor(type) {
                const side = Math.floor(Math.random() * 4);
                if (side === 0) { this.x = Math.random() * canvas.width; this.y = -20; }
                else if (side === 1) { this.x = canvas.width + 20; this.y = Math.random() * canvas.height; }
                else if (side === 2) { this.x = Math.random() * canvas.width; this.y = canvas.height + 20; }
                else { this.x = -20; this.y = Math.random() * canvas.height; }

                this.type = type;
                this.speed = enemySpeed;
                this.angle = 0;

                // Define enemy types with size and HP variations
                if (type === 'militant') { // Small, fast
                    this.radius = 12;
                    this.hp = 1;
                    this.color = '#8B4513'; // Brown robe
                    this.turbanColor = '#FFD700'; // Gold turban
                } else if (type === 'warrior') { // Medium, agile
                    this.radius = 15;
                    this.speed *= 1.5;
                    this.hp = 2;
                    this.color = '#A0522D'; // Sienna robe
                    this.turbanColor = '#228B22'; // Green turban
                } else if (type === 'commander') { // Large, slow
                    this.radius = 20;
                    this.speed *= 0.7;
                    this.hp = 4;
                    this.color = '#2F4F4F'; // Dark slate robe
                    this.turbanColor = '#800080'; // Purple turban
                }
                this.knockback = { x: 0, y: 0 };
            }
            update() {
                const dx = player.x - this.x;
                const dy = player.y - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                this.angle = Math.atan2(dy, dx);
                this.x += (dx / dist) * this.speed + this.knockback.x;
                this.y += (dy / dist) * this.speed + this.knockback.y;
                this.knockback.x *= 0.9;
                this.knockback.y *= 0.9;
            }
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);

                // Body (robe with gradient)
                const bodyGradient = ctx.createRadialGradient(0, 0, 5, 0, 0, this.radius);
                bodyGradient.addColorStop(0, this.color);
                bodyGradient.addColorStop(1, '#333');
                ctx.beginPath();
                ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = bodyGradient;
                ctx.fill();
                ctx.strokeStyle = '#222';
                ctx.lineWidth = 1;
                ctx.stroke();

                // Turban
                ctx.beginPath();
                ctx.arc(0, -this.radius * 0.6, this.radius * 0.7, 0, Math.PI * 2);
                ctx.fillStyle = this.turbanColor;
                ctx.fill();

                // Weapon (simple AK-47 style)
                ctx.fillStyle = '#444';
                ctx.fillRect(this.radius * 0.5, -2, this.radius, 3);

                // HP bar
                ctx.fillStyle = 'red';
                ctx.fillRect(-this.radius, -this.radius - 5, this.radius * 2 * (this.hp / (this.type === 'commander' ? 4 : this.type === 'warrior' ? 2 : 1)), 3);

                ctx.restore();
            }
            die() {
                for (let i = 0; i < 10; i++) {
                    particles.push(new Particle(this.x, this.y));
                }
            }
            hit(bullet) {
                this.hp -= Math.ceil(bullet.damage / 10);
                const knockbackForce = player.weapon.name === 'shotgun' ? 5 : 2;
                this.knockback.x = -bullet.dx * knockbackForce;
                this.knockback.y = -bullet.dy * knockbackForce;
            }
        }

        // Shooting function
        function shoot(e) {
            if (inTransition) return;
            const now = Date.now();
            if (now - player.lastShot < player.weapon.rate) return;
            player.lastShot = now;

            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            const dx = mouseX - player.x;
            const dy = mouseY - player.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            const dirX = dx / dist;
            const dirY = dy / dist;

            if (player.weapon.name === 'shotgun') {
                for (let i = 0; i < 5; i++) {
                    player.bullets.push(new Bullet(player.x, player.y, dirX, dirY, player.weapon.spread));
                }
            } else {
                player.bullets.push(new Bullet(player.x, player.y, dirX, dirY, player.weapon.spread));
            }

            player.recoilOffset.x = -dirX * player.weapon.recoil;
            player.recoilOffset.y = -dirY * player.weapon.recoil;
            setTimeout(() => { player.recoilOffset.x = 0; player.recoilOffset.y = 0; }, 100);
            muzzleFlashes.push(new MuzzleFlash(player.x + dirX * 20, player.y + dirY * 20, player.angle));
        }

        // Spawn enemies
        function spawnEnemy() {
            if (inTransition) return;
            let type = 'militant';
            if (round >= 10) type = Math.random() < 0.2 ? 'commander' : Math.random() < 0.3 ? 'warrior' : 'militant';
            else if (round >= 5) type = Math.random() < 0.3 ? 'warrior' : 'militant';
            enemies.push(new Enemy(type));
            setTimeout(spawnEnemy, spawnRate);
        }
        spawnEnemy();

        // Collision detection
        function checkCollision(a, b) {
            const dx = a.x - b.x;
            const dy = a.y - b.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            return dist < a.radius + b.radius;
        }

        // Upgrade system
        function buyUpgrade(type) {
            if (type === 'shotgun' && score >= 100) {
                player.weapon = { name: 'shotgun', damage: 20, rate: 800, spread: 0.2, recoil: 5, shots: 5 };
                score -= 100;
            } else if (type === 'rifle' && score >= 500) {
                player.weapon = { name: 'rifle', damage: 15, rate: 200, spread: 0.05, recoil: 3, shots: 1 };
                score -= 500;
            } else if (type === 'speed' && score >= 300) {
                player.speed = 7;
                score -= 300;
                setTimeout(() => player.speed = 5, 60000);
            } else if (type === 'health' && score >= 200) {
                player.hp = Math.min(player.hp + 50, 100);
                score -= 200;
            }
            scoreDisplay.textContent = score;
            healthDisplay.textContent = player.hp;
        }

        // Realistic player drawing
        function drawPlayer() {
            ctx.save();
            ctx.translate(player.x + player.recoilOffset.x, player.y + player.recoilOffset.y);
            ctx.rotate(player.angle);

            const bodyGradient = ctx.createRadialGradient(0, 0, 5, 0, 0, 15);
            bodyGradient.addColorStop(0, '#888');
            bodyGradient.addColorStop(1, '#444');
            ctx.beginPath();
            ctx.arc(0, 0, 15, 0, Math.PI * 2);
            ctx.fillStyle = bodyGradient;
            ctx.fill();
            ctx.strokeStyle = '#222';
            ctx.lineWidth = 2;
            ctx.stroke();

            const helmetGradient = ctx.createLinearGradient(0, -12, 0, -5);
            helmetGradient.addColorStop(0, '#00FFFF');
            helmetGradient.addColorStop(1, '#00CCCC');
            ctx.beginPath();
            ctx.arc(0, -8, 10, 0, Math.PI * 2);
            ctx.fillStyle = helmetGradient;
            ctx.fill();
            ctx.strokeStyle = '#006666';
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(-3, -10, 3, 0, Math.PI);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.fill();

            ctx.fillStyle = '#555';
            ctx.fillRect(-8, 5, 6, 10);
            ctx.fillRect(2, 5, 6, 10);
            ctx.strokeStyle = '#333';
            ctx.strokeRect(-8, 5, 6, 10);
            ctx.strokeRect(2, 5, 6, 10);

            ctx.fillStyle = '#666';
            ctx.fillRect(-12, -2, 8, 4);
            ctx.fillRect(10, -2, 8, 4);

            ctx.fillStyle = '#333';
            ctx.fillRect(10, -3, 15, 6);
            ctx.fillStyle = '#222';
            ctx.fillRect(15, -1, 10, 2);
            ctx.strokeStyle = '#111';
            ctx.lineWidth = 1;
            ctx.strokeRect(10, -3, 15, 6);

            ctx.fillStyle = '#000';
            ctx.fillRect(-6, -10, 12, 3);

            ctx.restore();
        }

        // Game loop
        function update() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (inTransition) {
                roundTransitionTime += 16;
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = 'white';
                ctx.font = '30px Arial';
                ctx.fillText(`Round ${round} Starting in ${Math.ceil((3000 - roundTransitionTime) / 1000)}s`, canvas.width / 2 - 150, canvas.height / 2);
                drawPlayer();
                if (roundTransitionTime >= 3000) {
                    inTransition = false;
                    roundTransitionTime = 0;
                    spawnEnemy(); // Restart spawning
                }
            } else {
                // Player movement
                if (keys['w'] && player.y > player.radius) player.y -= player.speed;
                if (keys['s'] && player.y < canvas.height - player.radius) player.y += player.speed;
                if (keys['a'] && player.x > player.radius) player.x -= player.speed;
                if (keys['d'] && player.x < canvas.width - player.radius) player.x += player.speed;

                // Round progression
                roundTime += 16;
                if (roundTime >= 60000) {
                    round++;
                    roundTime = 0;
                    inTransition = true;
                    enemySpeed *= 1.1;
                    spawnRate *= 0.9;
                    roundDisplay.textContent = round;
                    player.hp = Math.min(player.hp + 10, 100);
                    healthDisplay.textContent = player.hp;
                }
            }

            drawPlayer();

            player.bullets.forEach((bullet, bIndex) => {
                bullet.update();
                bullet.draw();
                if (bullet.x < 0 || bullet.x > canvas.width || bullet.y < 0 || bullet.y > canvas.height) {
                    player.bullets.splice(bIndex, 1);
                }
            });

            enemies.forEach((enemy, eIndex) => {
                enemy.update();
                enemy.draw();

                player.bullets.forEach((bullet, bIndex) => {
                    if (checkCollision(bullet, enemy)) {
                        enemy.hit(bullet);
                        player.bullets.splice(bIndex, 1);
                        if (enemy.hp <= 0) {
                            enemy.die();
                            enemies.splice(eIndex, 1);
                            score += enemy.type === 'commander' ? 50 : enemy.type === 'warrior' ? 30 : 20;
                            scoreDisplay.textContent = score;
                        }
                    }
                });

                if (checkCollision(player, enemy)) {
                    player.hp -= 10;
                    enemy.die();
                    enemies.splice(eIndex, 1);
                    healthDisplay.textContent = player.hp;
                    if (player.hp <= 0) {
                        alert(`Game Over! Score: ${score}`);
                        document.location.reload();
                    }
                }
            });

            particles.forEach((particle, pIndex) => {
                particle.update();
                particle.draw();
                if (particle.life <= 0) particles.splice(pIndex, 1);
            });

            muzzleFlashes.forEach((flash, fIndex) => {
                flash.update();
                flash.draw();
                if (flash.life <= 0) muzzleFlashes.splice(fIndex, 1);
            });

            requestAnimationFrame(update);
        }
        update();
    </script>
</body>
</html>