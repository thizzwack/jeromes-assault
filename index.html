<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Jerome’s Assault</title>
    <style>
        canvas {
            border: 1px solid black;
            display: block;
            margin: 0 auto;
        }
        body {
            text-align: center;
            background: #111;
            color: white;
            font-family: Arial, sans-serif;
        }
        #upgrades {
            margin: 10px;
        }
        button {
            padding: 5px 10px;
            margin: 5px;
            background: #333;
            color: white;
            border: 1px solid #555;
            cursor: pointer;
        }
        button:hover {
            background: #555;
        }
    </style>
</head>
<body>
    <h1>Jerome’s Assault</h1>
    <p>Score: <span id="score">1000</span> | Round: <span id="round">1</span> | HP: <span id="health">100</span></p>
    <div id="upgrades">
        <button onclick="buyUpgrade('shotgun')">Shotgun (100)</button>
        <button onclick="buyUpgrade('rifle')">Rifle (500)</button>
        <button onclick="buyUpgrade('speed')">Speed Boost (300)</button>
        <button onclick="buyUpgrade('health')">Health Pack (200)</button>
        <button onclick="buyUpgrade('grenade')">Grenade Launcher (300)</button>
        <button onclick="buyUpgrade('rocket')">Rocket Launcher (700)</button>
        <button onclick="buyUpgrade('flamethrower')">Flamethrower (600)</button>
    </div>
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score');
        const roundDisplay = document.getElementById('round');
        const healthDisplay = document.getElementById('health');
        const upgradesDiv = document.getElementById('upgrades');

        // Player object
        const player = {
            x: canvas.width / 2,
            y: canvas.height / 2,
            radius: 20,
            speed: 5,
            hp: 100,
            bullets: [],
            weapon: { name: 'pistol', damage: 10, rate: 500, spread: 0, recoil: 2, shots: 1, range: Infinity, explosionRadius: 0 },
            lastShot: 0,
            angle: 0,
            recoilOffset: { x: 0, y: 0 }
        };

        // Game state
        let enemies = [];
        let particles = [];
        let muzzleFlashes = [];
        let enemyBullets = [];
        let powerUps = [];
        let stars = [];
        let walls = [
            { x: 200, y: 150, width: 100, height: 20 },  // Representing fallen logs
            { x: 500, y: 400, width: 20, height: 100 },
            { x: 300, y: 500, width: 150, height: 20 }
        ];
        let bushes = [  // Replacing dunes with bushes
            { x: 150, y: 300, radius: 40 },
            { x: 600, y: 200, radius: 50 }
        ];
        let bulletsToExplode = [];
        let score = 1000;  // Start with 1000 points
        let round = 1;
        let roundTime = 0;
        let roundTransitionTime = 0;
        let inTransition = false;
        let enemySpeed = 2;
        let spawnRate = 5000;
        let backgroundOffset = 0;

        // Initialize stars
        for (let i = 0; i < 50; i++) {
            stars.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                radius: Math.random() * 2,
                speed: Math.random() * 0.5 + 0.5
            });
        }

        // Input handling
        const keys = {};
        window.addEventListener('keydown', (e) => keys[e.key] = true);
        window.addEventListener('keyup', (e) => keys[e.key] = false);
        canvas.addEventListener('click', shoot);
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            player.angle = Math.atan2(mouseY - player.y, mouseX - player.x);
        });

        // Bullet class
        class Bullet {
            constructor(x, y, dx, dy, spread) {
                this.x = x;
                this.y = y;
                this.dx = dx + (Math.random() - 0.5) * spread;
                this.dy = dy + (Math.random() - 0.5) * spread;
                this.radius = player.weapon.name === 'shotgun' ? 3 : player.weapon.name === 'grenade' ? 8 : player.weapon.name === 'rocket' ? 10 : player.weapon.name === 'flamethrower' ? 5 : 5;
                this.speed = player.weapon.name === 'rifle' ? 15 : player.weapon.name === 'rocket' ? 12 : player.weapon.name === 'flamethrower' ? 8 : 10;
                this.damage = player.weapon.damage;
                this.range = player.weapon.range;
                this.explosionRadius = player.weapon.explosionRadius;
                this.distanceTraveled = 0;
                this.isFlame = player.weapon.name === 'flamethrower';
                this.hasExploded = false;
            }
            update() {
                this.x += this.dx * this.speed;
                this.y += this.dy * this.speed;
                this.distanceTraveled += this.speed;
                if (this.isFlame) {
                    particles.push(new Particle(this.x, this.y, 'orange'));
                }
            }
            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.isFlame ? 'orange' : player.weapon.name === 'rifle' ? '#FFA500' : player.weapon.name === 'grenade' ? '#666' : player.weapon.name === 'rocket' ? '#FF4500' : 'yellow';
                ctx.fill();
            }
            explode() {
                if (this.hasExploded || this.explosionRadius === 0) return;
                this.hasExploded = true;
                for (let i = 0; i < 20; i++) {
                    particles.push(new Particle(this.x, this.y, Math.random() < 0.5 ? 'orange' : 'yellow'));
                }
                particles.push({ x: this.x, y: this.y, radius: 0, maxRadius: this.explosionRadius, life: 20, color: 'rgba(255, 165, 0, 0.5)' });
            }
        }

        // EnemyBullet class
        class EnemyBullet {
            constructor(x, y, dx, dy) {
                this.x = x;
                this.y = y;
                this.dx = dx;
                this.dy = dy;
                this.speed = 5;
                this.radius = 4;
            }
            update() {
                this.x += this.dx * this.speed;
                this.y += this.dy * this.speed;
            }
            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = 'red';
                ctx.fill();
            }
        }

        // Particle class
        class Particle {
            constructor(x, y, color = null) {
                this.x = x;
                this.y = y;
                this.radius = Math.random() * 3 + 1;
                this.dx = (Math.random() - 0.5) * 4;
                this.dy = (Math.random() - 0.5) * 4;
                this.life = color === 'rgba(255, 165, 0, 0.5)' ? 20 : 30;
                this.color = color || (Math.random() < 0.5 ? '#8B0000' : '#FF0000');
                this.isShockwave = color === 'rgba(255, 165, 0, 0.5)';
                if (this.isShockwave) {
                    this.radius = 0;
                    this.maxRadius = 50; // Default, overridden by explosion
                }
            }
            update() {
                if (this.isShockwave) {
                    this.radius += this.maxRadius / this.life;
                    this.life--;
                } else {
                    this.x += this.dx;
                    this.y += this.dy;
                    this.life--;
                    this.radius *= 0.95;
                }
            }
            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
            }
        }

        // Muzzle flash class
        class MuzzleFlash {
            constructor(x, y, angle) {
                this.x = x;
                this.y = y;
                this.angle = angle;
                this.life = 5;
            }
            update() {
                this.life--;
            }
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(15, 5);
                ctx.lineTo(25, 0);
                ctx.lineTo(15, -5);
                ctx.fillStyle = 'rgba(255, 165, 0, ' + (this.life / 5) + ')';
                ctx.fill();
                ctx.restore();
            }
        }

        // Enemy class
        class Enemy {
            constructor(type) {
                const side = Math.floor(Math.random() * 4);
                if (side === 0) { this.x = Math.random() * canvas.width; this.y = -20; }
                else if (side === 1) { this.x = canvas.width + 20; this.y = Math.random() * canvas.height; }
                else if (side === 2) { this.x = Math.random() * canvas.width; this.y = canvas.height + 20; }
                else { this.x = -20; this.y = Math.random() * canvas.height; }

                this.type = type;
                this.speed = enemySpeed;
                this.angle = 0;

                if (type === 'militant') {
                    this.radius = 12;
                    this.hp = 1;
                    this.color = '#556B2F'; // Dark olive green
                    this.turbanColor = '#8B4513'; // Brown
                } else if (type === 'warrior') {
                    this.radius = 15;
                    this.speed *= 1.5;
                    this.hp = 2;
                    this.color = '#6B8E23'; // Olive drab
                    this.turbanColor = '#228B22'; // Forest green
                    this.shootCooldown = Math.random() * 2000 + 1000;
                } else if (type === 'commander') {
                    this.radius = 20;
                    this.speed *= 0.7;
                    this.hp = 4;
                    this.color = '#2F4F4F'; // Dark slate gray
                    this.turbanColor = '#483D8B'; // Dark slate blue
                    this.spawnCooldown = 5000;
                }
                this.knockback = { x: 0, y: 0 };
            }
            update() {
                const dx = player.x - this.x;
                const dy = player.y - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                this.angle = Math.atan2(dy, dx);

                let effectiveSpeed = this.speed;
                if (this.type === 'commander' && dist > 100) effectiveSpeed = 0;

                let newX = this.x + (dx / dist) * effectiveSpeed + this.knockback.x;
                let newY = this.y + (dy / dist) * effectiveSpeed + this.knockback.y;

                let collided = false;
                walls.forEach(wall => {
                    if (this.checkWallCollision(wall, newX, newY)) {
                        collided = true;
                    }
                });
                if (!collided) {
                    this.x = newX;
                    this.y = newY;
                }

                this.knockback.x *= 0.9;
                this.knockback.y *= 0.9;

                if (this.type === 'warrior' && Date.now() - (this.lastShot || 0) > this.shootCooldown) {
                    this.shoot();
                    this.lastShot = Date.now();
                }

                if (this.type === 'commander' && Date.now() - (this.lastSpawn || 0) > this.spawnCooldown) {
                    this.spawnMinion();
                    this.lastSpawn = Date.now();
                }
            }
            shoot() {
                const dx = player.x - this.x;
                const dy = player.y - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                enemyBullets.push(new EnemyBullet(this.x, this.y, dx / dist, dy / dist));
            }
            spawnMinion() {
                enemies.push(new Enemy('militant'));
            }
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);

                const bodyGradient = ctx.createRadialGradient(0, 0, 5, 0, 0, this.radius);
                bodyGradient.addColorStop(0, this.color);
                bodyGradient.addColorStop(1, '#333');
                ctx.beginPath();
                ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = bodyGradient;
                ctx.fill();
                ctx.strokeStyle = '#222';
                ctx.lineWidth = 1;
                ctx.stroke();

                ctx.beginPath();
                ctx.arc(0, -this.radius * 0.6, this.radius * 0.7, 0, Math.PI * 2);
                ctx.fillStyle = this.turbanColor;
                ctx.fill();

                ctx.fillStyle = '#444';
                ctx.fillRect(this.radius * 0.5, -2, this.radius, 3);

                ctx.fillStyle = 'red';
                ctx.fillRect(-this.radius, -this.radius - 5, this.radius * 2 * (this.hp / (this.type === 'commander' ? 4 : this.type === 'warrior' ? 2 : 1)), 3);

                ctx.restore();
            }
            die() {
                for (let i = 0; i < 10; i++) {
                    particles.push(new Particle(this.x, this.y));
                }
                for (let i = 0; i < 5; i++) {
                    particles.push(new Particle(this.x, this.y, 'orange'));
                }
                spawnPowerUp(this.x, this.y);
            }
            hit(bullet) {
                this.hp -= Math.ceil(bullet.damage / 10);
                const knockbackForce = player.weapon.name === 'shotgun' ? 5 : player.weapon.explosionRadius > 0 ? 8 : 2;
                this.knockback.x = -bullet.dx * knockbackForce;
                this.knockback.y = -bullet.dy * knockbackForce;
                if (this.hp <= 0) this.die();
            }
            checkWallCollision(wall, x = this.x, y = this.y) {
                return (
                    x + this.radius > wall.x &&
                    x - this.radius < wall.x + wall.width &&
                    y + this.radius > wall.y &&
                    y - this.radius < wall.y + wall.height
                );
            }
        }

        // Shooting function
        function shoot(e) {
            const now = Date.now();
            if (now - player.lastShot < player.weapon.rate) return;
            player.lastShot = now;

            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            const dx = mouseX - player.x;
            const dy = mouseY - player.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            const dirX = dx / dist;
            const dirY = dy / dist;

            if (player.weapon.name === 'shotgun') {
                for (let i = 0; i < 5; i++) {
                    player.bullets.push(new Bullet(player.x, player.y, dirX, dirY, player.weapon.spread));
                }
            } else if (player.weapon.name === 'flamethrower') {
                for (let i = 0; i < 3; i++) {
                    player.bullets.push(new Bullet(player.x, player.y, dirX + (Math.random() - 0.5) * 0.2, dirY + (Math.random() - 0.5) * 0.2, player.weapon.spread));
                }
            } else {
                player.bullets.push(new Bullet(player.x, player.y, dirX, dirY, player.weapon.spread));
            }

            player.recoilOffset.x = -dirX * player.weapon.recoil;
            player.recoilOffset.y = -dirY * player.weapon.recoil;
            setTimeout(() => { player.recoilOffset.x = 0; player.recoilOffset.y = 0; }, 100);
            muzzleFlashes.push(new MuzzleFlash(player.x + dirX * 20, player.y + dirY * 20, player.angle));
        }

        // Spawn enemies
        function spawnEnemy() {
            if (inTransition) return;
            let type = 'militant';
            if (round >= 10) type = Math.random() < 0.2 ? 'commander' : Math.random() < 0.3 ? 'warrior' : 'militant';
            else if (round >= 5) type = Math.random() < 0.3 ? 'warrior' : 'militant';
            enemies.push(new Enemy(type));
            setTimeout(spawnEnemy, spawnRate);
        }
        spawnEnemy();

        // Spawn power-up
        function spawnPowerUp(x, y) {
            if (Math.random() < 0.2) {
                powerUps.push({
                    x, y,
                    type: ['health', 'speed', 'damage'][Math.floor(Math.random() * 3)],
                    radius: 10,
                    life: 5000
                });
            }
        }

        // Collision detection
        function checkCollision(a, b) {
            const dx = a.x - b.x;
            const dy = a.y - b.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            return dist < a.radius + b.radius;
        }

        // Wall collision for bullets
        function checkBulletWallCollision(bullet, wall) {
            return (
                bullet.x + bullet.radius > wall.x &&
                bullet.x - bullet.radius < wall.x + wall.width &&
                bullet.y + bullet.radius > wall.y &&
                bullet.y - bullet.radius < wall.y + wall.height
            );
        }

        // Bush collision
        function checkBushCollision(obj, bush) {
            const dist = Math.sqrt((obj.x - bush.x) ** 2 + (obj.y - bush.y) ** 2);
            return dist < obj.radius + bush.radius;
        }

        // Upgrade system
        function buyUpgrade(type) {
            if (type === 'shotgun' && score >= 100) {
                player.weapon = { name: 'shotgun', damage: 20, rate: 800, spread: 0.2, recoil: 5, shots: 5, range: Infinity, explosionRadius: 0 };
                score -= 100;
            } else if (type === 'rifle' && score >= 500) {
                player.weapon = { name: 'rifle', damage: 15, rate: 200, spread: 0.05, recoil: 3, shots: 1, range: Infinity, explosionRadius: 0 };
                score -= 500;
            } else if (type === 'speed' && score >= 300) {
                player.speed = 7;
                score -= 300;
                setTimeout(() => player.speed = 5, 60000);
            } else if (type === 'health' && score >= 200) {
                player.hp = Math.min(player.hp + 50, 100);
                score -= 200;
            } else if (type === 'grenade' && score >= 300) {
                player.weapon = { name: 'grenade', damage: 50, rate: 1000, spread: 0, recoil: 6, shots: 1, range: 200, explosionRadius: 50 };
                score -= 300;
            } else if (type === 'rocket' && score >= 700) {
                player.weapon = { name: 'rocket', damage: 80, rate: 1500, spread: 0, recoil: 8, shots: 1, range: Infinity, explosionRadius: 80 };
                score -= 700;
            } else if (type === 'flamethrower' && score >= 600) {
                player.weapon = { name: 'flamethrower', damage: 5, rate: 50, spread: 0.2, recoil: 1, shots: 3, range: 100, explosionRadius: 0 };
                score -= 600;
            }
            scoreDisplay.textContent = score;
            healthDisplay.textContent = player.hp;
        }

        // Player drawing
        function drawPlayer() {
            ctx.save();
            ctx.translate(player.x + player.recoilOffset.x, player.y + player.recoilOffset.y);
            ctx.rotate(player.angle);

            const bodyGradient = ctx.createRadialGradient(0, 0, 5, 0, 0, 15);
            bodyGradient.addColorStop(0, '#888');
            bodyGradient.addColorStop(1, '#444');
            ctx.beginPath();
            ctx.arc(0, 0, 15, 0, Math.PI * 2);
            ctx.fillStyle = bodyGradient;
            ctx.fill();
            ctx.strokeStyle = '#222';
            ctx.lineWidth = 2;
            ctx.stroke();

            const helmetGradient = ctx.createLinearGradient(0, -12, 0, -5);
            helmetGradient.addColorStop(0, '#228B22'); // Forest green helmet
            helmetGradient.addColorStop(1, '#006400'); // Dark green
            ctx.beginPath();
            ctx.arc(0, -8, 10, 0, Math.PI * 2);
            ctx.fillStyle = helmetGradient;
            ctx.fill();
            ctx.strokeStyle = '#004d00';
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(-3, -10, 3, 0, Math.PI);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.fill();

            ctx.fillStyle = '#555';
            ctx.fillRect(-8, 5, 6, 10);
            ctx.fillRect(2, 5, 6, 10);
            ctx.strokeStyle = '#333';
            ctx.strokeRect(-8, 5, 6, 10);
            ctx.strokeRect(2, 5, 6, 10);

            ctx.fillStyle = '#666';
            ctx.fillRect(-12, -2, 8, 4);
            ctx.fillRect(10, -2, 8, 4);

            ctx.fillStyle = '#333';
            ctx.fillRect(10, -3, 15, 6);
            ctx.fillStyle = '#222';
            ctx.fillRect(15, -1, 10, 2);
            ctx.strokeStyle = '#111';
            ctx.lineWidth = 1;
            ctx.strokeRect(10, -3, 15, 6);

            ctx.fillStyle = '#000';
            ctx.fillRect(-6, -10, 12, 3);

            ctx.restore();
        }

        // Game loop
        function update() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Wilderness-themed background
            const skyGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            skyGradient.addColorStop(0, '#87CEFA'); // Light blue sky
            skyGradient.addColorStop(1, '#228B22'); // Forest green ground
            ctx.fillStyle = skyGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Scrolling trees
            backgroundOffset += 0.5;
            if (backgroundOffset > canvas.height) backgroundOffset = 0;
            ctx.fillStyle = '#006400'; // Dark green for trees
            for (let i = -1; i < 2; i++) {
                ctx.beginPath();
                ctx.moveTo(100, canvas.height - 50 + backgroundOffset + i * canvas.height);
                ctx.lineTo(120, canvas.height - 100 + backgroundOffset + i * canvas.height);
                ctx.lineTo(140, canvas.height - 50 + backgroundOffset + i * canvas.height);
                ctx.fill();
                ctx.beginPath();
                ctx.moveTo(400, canvas.height - 60 + backgroundOffset + i * canvas.height);
                ctx.lineTo(420, canvas.height - 120 + backgroundOffset + i * canvas.height);
                ctx.lineTo(440, canvas.height - 60 + backgroundOffset + i * canvas.height);
                ctx.fill();
            }

            // Draw stars
            stars.forEach(star => {
                star.y += star.speed;
                if (star.y > canvas.height) star.y = -star.radius;
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
                ctx.fillStyle = 'white';
                ctx.fill();
            });

            // Draw walls (logs)
            walls.forEach(wall => {
                ctx.fillStyle = '#8B4513'; // Brown logs
                ctx.fillRect(wall.x, wall.y, wall.width, wall.height);
            });

            // Draw bushes
            bushes.forEach(bush => {
                ctx.beginPath();
                ctx.arc(bush.x, bush.y, bush.radius, 0, Math.PI * 2);
                ctx.fillStyle = '#228B22'; // Green bushes
                ctx.fill();
            });

            if (inTransition) {
                roundTransitionTime += 16;
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = 'white';
                ctx.font = '30px Arial';
                ctx.fillText(`Round ${round} Starting in ${Math.ceil((3000 - roundTransitionTime) / 1000)}s`, canvas.width / 2 - 150, canvas.height / 2);
                if (roundTransitionTime >= 3000) {
                    inTransition = false;
                    roundTransitionTime = 0;
                    spawnEnemy();
                }
            } else {
                // Player movement
                let newX = player.x;
                let newY = player.y;
                if (keys['w'] && player.y > player.radius) newY -= player.speed;
                if (keys['s'] && player.y < canvas.height - player.radius) newY += player.speed;
                if (keys['a'] && player.x > player.radius) newX -= player.speed;
                if (keys['d'] && player.x < canvas.width - player.radius) newX += player.speed;

                let collided = false;
                walls.forEach(wall => {
                    if (
                        newX + player.radius > wall.x &&
                        newX - player.radius < wall.x + wall.width &&
                        newY + player.radius > wall.y &&
                        newY - player.radius < wall.y + wall.height
                    ) {
                        collided = true;
                    }
                });
                if (!collided) {
                    player.x = newX;
                    player.y = newY;
                }

                // Round progression
                roundTime += 16;
                if (roundTime >= 60000) {
                    round++;
                    roundTime = 0;
                    inTransition = true;
                    enemySpeed *= 1.1;
                    spawnRate *= 0.9;
                    roundDisplay.textContent = round;
                    player.hp = Math.min(player.hp + 10, 100);
                    healthDisplay.textContent = player.hp;
                }
            }

            drawPlayer();

            // Player bullets
            for (let bIndex = player.bullets.length - 1; bIndex >= 0; bIndex--) {
                const bullet = player.bullets[bIndex];
                bullet.update();
                bullet.draw();

                let shouldRemove = bullet.x < 0 || bullet.x > canvas.width || bullet.y < 0 || bullet.y > canvas.height || bullet.distanceTraveled > bullet.range;

                walls.forEach(wall => {
                    if (checkBulletWallCollision(bullet, wall)) {
                        shouldRemove = true;
                        if (bullet.explosionRadius > 0 && !bullet.hasExploded) bulletsToExplode.push(bullet);
                    }
                });
                bushes.forEach(bush => {
                    if (checkBushCollision(bullet, bush)) {
                        shouldRemove = true;
                        if (bullet.explosionRadius > 0 && !bullet.hasExploded) bulletsToExplode.push(bullet);
                    }
                });

                if (shouldRemove) {
                    player.bullets.splice(bIndex, 1);
                    continue;
                }

                for (let eIndex = enemies.length - 1; eIndex >= 0; eIndex--) {
                    const enemy = enemies[eIndex];
                    if (checkCollision(bullet, enemy)) {
                        enemy.hit(bullet);
                        if (bullet.explosionRadius > 0 && !bullet.hasExploded) bulletsToExplode.push(bullet);
                        else player.bullets.splice(bIndex, 1);
                        if (enemy.hp <= 0) {
                            enemies.splice(eIndex, 1);
                            score += enemy.type === 'commander' ? 50 : enemy.type === 'warrior' ? 30 : 20;
                            scoreDisplay.textContent = score;
                        }
                        break;
                    }
                }
            }

            // Process explosions after bullet updates
            bulletsToExplode.forEach(bullet => {
                bullet.explode();
                enemies.forEach(enemy => {
                    const dist = Math.sqrt((enemy.x - bullet.x) ** 2 + (enemy.y - bullet.y) ** 2);
                    if (dist < bullet.explosionRadius) {
                        enemy.hp -= bullet.damage / 10;
                        enemy.knockback.x += (enemy.x - bullet.x) / dist * 5;
                        enemy.knockback.y += (enemy.y - bullet.y) / dist * 5;
                        if (enemy.hp <= 0) {
                            const eIndex = enemies.indexOf(enemy);
                            if (eIndex !== -1) {
                                enemies.splice(eIndex, 1);
                                score += enemy.type === 'commander' ? 50 : enemy.type === 'warrior' ? 30 : 20;
                                scoreDisplay.textContent = score;
                            }
                        }
                    }
                });
                const bIndex = player.bullets.indexOf(bullet);
                if (bIndex !== -1) player.bullets.splice(bIndex, 1);
            });
            bulletsToExplode = [];

            // Enemies
            enemies.forEach((enemy, eIndex) => {
                enemy.update();
                enemy.draw();

                if (checkCollision(player, enemy)) {
                    player.hp -= 10;
                    enemy.die();
                    enemies.splice(eIndex, 1);
                    healthDisplay.textContent = player.hp;
                    if (player.hp <= 0) {
                        alert(`Game Over! Score: ${score}`);
                        document.location.reload();
                    }
                }
            });

            // Enemy bullets
            for (let bIndex = enemyBullets.length - 1; bIndex >= 0; bIndex--) {
                const bullet = enemyBullets[bIndex];
                bullet.update();
                bullet.draw();
                let shouldRemove = bullet.x < 0 || bullet.x > canvas.width || bullet.y < 0 || bullet.y > canvas.height;
                walls.forEach(wall => {
                    if (checkBulletWallCollision(bullet, wall)) shouldRemove = true;
                });
                bushes.forEach(bush => {
                    if (checkBushCollision(bullet, bush)) shouldRemove = true;
                });

                if (shouldRemove) {
                    enemyBullets.splice(bIndex, 1);
                } else if (checkCollision(bullet, player)) {
                    player.hp -= 5;
                    enemyBullets.splice(bIndex, 1);
                    healthDisplay.textContent = player.hp;
                    if (player.hp <= 0) {
                        alert(`Game Over! Score: ${score}`);
                        document.location.reload();
                    }
                }
            }

            // Particles
            particles.forEach((particle, pIndex) => {
                particle.update();
                particle.draw();
                if (particle.life <= 0) particles.splice(pIndex, 1);
            });

            // Muzzle flashes
            muzzleFlashes.forEach((flash, fIndex) => {
                flash.update();
                flash.draw();
                if (flash.life <= 0) muzzleFlashes.splice(fIndex, 1);
            });

            // Power-ups
            powerUps.forEach((powerUp, pIndex) => {
                powerUp.life -= 16;
                ctx.beginPath();
                ctx.arc(powerUp.x, powerUp.y, powerUp.radius, 0, Math.PI * 2);
                ctx.fillStyle = powerUp.type === 'health' ? 'green' : powerUp.type === 'speed' ? 'blue' : 'purple';
                ctx.fill();
                if (checkCollision(player, powerUp)) {
                    if (powerUp.type === 'health') player.hp = Math.min(player.hp + 20, 100);
                    else if (powerUp.type === 'speed') {
                        player.speed = 8;
                        setTimeout(() => player.speed = 5, 10000);
                    } else if (powerUp.type === 'damage') {
                        const oldDamage = player.weapon.damage;
                        player.weapon.damage *= 2;
                        setTimeout(() => player.weapon.damage = oldDamage, 10000);
                    }
                    powerUps.splice(pIndex, 1);
                    healthDisplay.textContent = player.hp;
                }
                if (powerUp.life <= 0) powerUps.splice(pIndex, 1);
            });

            requestAnimationFrame(update);
        }
        update();
    </script>
</body>
</html>
